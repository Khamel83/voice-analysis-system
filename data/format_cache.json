{
  ".eml": {
    "format_type": "The provided file content is an email message saved in the EML format. EML files are standard email message files that store the email's headers, body (which can be plain text, HTML, or both), and attachments.",
    "strategy": "To extract human-readable text content from an EML file, we should leverage Python's built-in `email` package. This package is designed to parse email messages according to RFC 822 and RFC 2822 standards. The strategy involves: \n1. Reading the EML file content.\n2. Parsing the content using `email.parser.Parser` to create an `email.message.Message` object.\n3. Iterating through the parts of the email message. Emails can be multipart, containing different content types (e.g., text/plain, text/html, attachments). \n4. For each part, checking its content type. We are interested in `text/plain` parts for direct human-readable text. If `text/html` is present and no `text/plain` is found, we can attempt to extract text from HTML, though this is more complex and might require additional libraries. For this task, prioritizing `text/plain` is sufficient.\n5. Decoding the content of the relevant parts, as email content can be encoded (e.g., base64, quoted-printable).\n6. Skipping any parts that are not text-based (like attachments) or are purely metadata.",
    "python_code": "import email\nfrom email import policy\nfrom email.parser import BytesParser\nimport os\n\ndef process_eml_file(file_path):\n    \"\"\"\n    Extracts human-readable text content from an EML file.\n\n    Args:\n        file_path (str): The path to the .eml file.\n\n    Returns:\n        list: A list of strings, where each string is a piece of human-readable text content.\n              Returns an empty list if the file cannot be processed or contains no text.\n    \"\"\"\n    text_content = []\n    if not os.path.exists(file_path):\n        print(f\"Error: File not found at {file_path}\")\n        return text_content\n\n    try:\n        with open(file_path, 'rb') as f:\n            msg = BytesParser(policy=policy.default).parse(f)\n\n        if msg.is_multipart():\n            for part in msg.walk():\n                content_type = part.get_content_type()\n                content_disposition = str(part.get('Content-Disposition'))\n\n                # Skip attachments and non-text parts\n                if 'attachment' not in content_disposition and content_type in ['text/plain', 'text/html']:\n                    try:\n                        payload = part.get_payload(decode=True)\n                        charset = part.get_content_charset() or 'utf-8' # Default to utf-8 if not specified\n                        decoded_payload = payload.decode(charset, errors='ignore')\n                        \n                        # For text/html, a simple approach is to just add it, but for writing analysis,\n                        # plain text is usually preferred. If only HTML is available, one might\n                        # consider using a library like BeautifulSoup to extract text.\n                        # For this function, we prioritize text/plain.\n                        if content_type == 'text/plain':\n                            text_content.append(decoded_payload)\n                        # elif content_type == 'text/html':\n                        #     # Basic HTML to text extraction (can be improved with libraries like BeautifulSoup)\n                        #     import re\n                        #     clean_text = re.sub('<.*?>', '', decoded_payload)\n                        #     text_content.append(clean_text)\n\n                    except Exception as e:\n                        print(f\"Warning: Could not decode part with content type {content_type}: {e}\")\n        else:\n            # Not a multipart message, assume it's a single text part\n            content_type = msg.get_content_type()\n            if content_type in ['text/plain', 'text/html']:\n                try:\n                    payload = msg.get_payload(decode=True)\n                    charset = msg.get_content_charset() or 'utf-8'\n                    decoded_payload = payload.decode(charset, errors='ignore')\n                    if content_type == 'text/plain':\n                        text_content.append(decoded_payload)\n                    # elif content_type == 'text/html':\n                    #     import re\n                    #     clean_text = re.sub('<.*?>', '', decoded_payload)\n                    #     text_content.append(clean_text)\n                except Exception as e:\n                    print(f\"Warning: Could not decode message payload with content type {content_type}: {e}\")\n\n    except Exception as e:\n        print(f\"Error processing EML file {file_path}: {e}\")\n\n    return text_content\n",
    "imports_needed": [
      "email",
      "email.policy",
      "email.parser",
      "os"
    ],
    "confidence": 0.98
  }
}