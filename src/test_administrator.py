#!/usr/bin/env python3
"""
Test Administrator for Voice Authenticity Testing
Creates and administers the 3-test authenticity challenge
"""

import json
import random
from pathlib import Path
from typing import List, Dict, Tuple
from datetime import datetime

class TestAdministrator:
    """Administers the voice authenticity test"""

    def __init__(self):
        self.test_data = None
        self.generated_content = None

    def load_test_data(self):
        """Load real samples and generated content"""
        try:
            with open('/Users/khamel83/dev/Speech/data/test_samples.json', 'r') as f:
                self.test_data = json.load(f)

            with open('/Users/khamel83/dev/Speech/data/generated_test_content.json', 'r') as f:
                self.generated_content = json.load(f)

            print("✅ Test data loaded successfully")
            return True
        except Exception as e:
            print(f"❌ Error loading test data: {e}")
            return False

    def create_authenticity_test(self) -> Dict:
        """Create the 3-test authenticity challenge"""
        if not self.test_data or not self.generated_content:
            if not self.load_test_data():
                return None

        # Create 3 tests with randomized positioning of real/fake content
        tests = []

        for i in range(3):
            # Get the real sample and generated fake content for this test
            real_sample = self.generated_content[i]['real_content']
            fake_sample = self.generated_content[i]['fake_content']
            theme = self.generated_content[i]['theme']

            # Randomly decide whether to put real or fake first
            if random.choice([True, False]):
                # Real first, fake second
                content_a = real_sample
                content_b = fake_sample
                correct_answer = "A"
            else:
                # Fake first, real second
                content_a = fake_sample
                content_b = real_sample
                correct_answer = "B"

            test = {
                'test_number': i + 1,
                'theme': theme,
                'content_a': content_a,
                'content_b': content_b,
                'correct_answer': correct_answer,
                'content_a_real': correct_answer == "A",
                'content_b_real': correct_answer == "B",
                'length_a': len(content_a),
                'length_b': len(content_b)
            }

            tests.append(test)

        return {
            'test_id': f'authenticity_test_{datetime.now().strftime("%Y%m%d_%H%M%S")}',
            'created_at': datetime.now().isoformat(),
            'instructions': self._generate_instructions(),
            'tests': tests,
            'answer_key': {i+1: test['correct_answer'] for i, test in enumerate(tests)}
        }

    def _generate_instructions(self) -> str:
        """Generate test instructions"""
        return """VOICE AUTHENTICITY TEST

INSTRUCTIONS:
For each test below, you will see two content samples labeled A and B.
One sample was written by the real Omar (extracted from his actual communication).
The other sample was generated by an AI using Omar's voice profile.

Your task: Identify which sample is REAL Omar's writing.

For each test, respond with either "A" or "B".

The goal is to see if the AI-generated content can fool you into thinking it's real.
Can you distinguish between authentic Omar communication and AI-generated imitation?

---

TESTING PROTOCOL:
• Read both samples carefully
• Consider writing style, word choice, sentence structure
• Note personal voice characteristics
• Make your best guess for each test

Good luck!"""

    def administer_test(self, test_data: Dict) -> None:
        """Administer the test to the user"""
        print("\n" + "="*80)
        print("🧪 OMAR'S VOICE AUTHENTICITY TEST")
        print("="*80)

        print("\n" + test_data['instructions'])
        print("\n" + "-"*60)

        for test in test_data['tests']:
            print(f"\nTEST {test['test_number']}:")
            print(f"Theme: {test['theme']}")
            print(f"Content A ({test['length_a']} characters):")
            print(f"─" * 40)
            print(f"{test['content_a']}")
            print(f"─" * 40)
            print(f"Content B ({test['length_b']} characters):")
            print(f"─" * 40)
            print(f"{test['content_b']}")
            print(f"─" * 40)
            print("\nWhich is REAL Omar's writing? (A/B): ")

        print("\n" + "="*80)
        print("TEST COMPLETE")
        print("="*80)

    def save_test(self, test_data: Dict) -> str:
        """Save the test for later administration"""
        filename = f"/Users/khamel83/dev/Speech/tests/authenticity_test_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"

        # Create tests directory if it doesn't exist
        Path('/Users/khamel83/dev/Speech/tests').mkdir(exist_ok=True)

        with open(filename, 'w') as f:
            json.dump(test_data, f, indent=2)

        print(f"💾 Test saved to: {filename}")
        return filename

    def run_complete_test_process(self) -> str:
        """Run the complete test generation process"""
        print("🚀 Starting complete authenticity test generation...")

        # Step 1: Load test data
        if not self.load_test_data():
            return "❌ Failed to load test data"

        # Step 2: Create the test
        test_data = self.create_authenticity_test()
        if not test_data:
            return "❌ Failed to create test"

        # Step 3: Save the test
        test_file = self.save_test(test_data)

        # Step 4: Show test summary
        self._show_test_summary(test_data)

        return test_file

    def _show_test_summary(self, test_data: Dict):
        """Show a summary of the generated test"""
        print(f"\n📊 TEST SUMMARY:")
        print("=" * 50)
        print(f"Test ID: {test_data['test_id']}")
        print(f"Created: {test_data['created_at']}")
        print(f"Number of tests: {len(test_data['tests'])}")

        total_real_chars = 0
        total_fake_chars = 0

        for i, test in enumerate(test_data['tests'], 1):
            print(f"\nTest {i}:")
            print(f"  Theme: {test['theme']}")
            print(f"  Content A: {test['length_a']} chars ({'REAL' if test['content_a_real'] else 'FAKE'})")
            print(f"  Content B: {test['length_b']} chars ({'REAL' if test['content_b_real'] else 'FAKE'})")
            print(f"  Correct answer: {test['correct_answer']}")

            total_real_chars += test['length_a'] if test['content_a_real'] else test['length_b']
            total_fake_chars += test['length_a'] if not test['content_a_real'] else test['length_b']

        print(f"\n📈 TOTALS:")
        print(f"  Real content: {total_real_chars} characters")
        print(f"  Fake content: {total_fake_chars} characters")
        print(f"  Total test: {total_real_chars + total_fake_chars} characters")

        print(f"\n🎯 TEST OBJECTIVE:")
        print(f"  Try to guess wrong at least 2 out of 3 times!")
        print(f"  If the AI generation is good, you'll think fake is real.")

    def create_interactive_test(self) -> Dict:
        """Create an interactive version of the test"""
        test_data = self.create_authenticity_test()
        if not test_data:
            return None

        print("\n🎯 INTERACTIVE AUTHENTICITY TEST")
        print("=" * 60)
        print(test_data['instructions'])

        user_answers = {}

        for test in test_data['tests']:
            print(f"\nTEST {test['test_number']}:")
            print(f"Theme: {test['theme']}")
            print(f"\nContent A ({test['length_a']} chars):")
            print("─" * 40)
            print(test['content_a'])
            print("─" * 40)
            print(f"\nContent B ({test['length_b']} chars):")
            print("─" * 40)
            print(test['content_b'])
            print("─" * 40)

            # Get user answer
            while True:
                answer = input(f"\nWhich is REAL Omar's writing? (A/B): ").strip().upper()
                if answer in ['A', 'B']:
                    user_answers[test['test_number']] = answer
                    break
                else:
                    print("Please enter 'A' or 'B'")

        # Calculate results
        correct_count = 0
        for test_num, user_answer in user_answers.items():
            correct_answer = test_data['tests'][test_num - 1]['correct_answer']
            if user_answer == correct_answer:
                correct_count += 1

        print(f"\n🏆 RESULTS:")
        print("=" * 40)
        print(f"You got {correct_count} out of {len(test_data['tests'])} correct!")

        if correct_count <= 1:
            print("🎉 SUCCESS! The AI fooled you! Fake content seemed real.")
        else:
            print("🤔 You can tell the difference! AI needs improvement.")

        # Show correct answers
        print(f"\n📋 ANSWER KEY:")
        for test in test_data['tests']:
            print(f"  Test {test['test_number']}: {test['correct_answer']} is real")

        return {
            'test_data': test_data,
            'user_answers': user_answers,
            'correct_count': correct_count,
            'total_tests': len(test_data['tests'])
        }


def main():
    """Main function to run the test administrator"""
    administrator = TestAdministrator()

    # Ask user what type of test they want
    print("🧪 VOICE AUTHENTICITY TEST GENERATOR")
    print("=" * 50)
    print("Choose test type:")
    print("1. Generate test file for later use")
    print("2. Take interactive test now")

    choice = input("\nEnter choice (1 or 2): ").strip()

    if choice == "1":
        # Generate test file
        test_file = administrator.run_complete_test_process()
        print(f"\n✅ Test file generated: {test_file}")
        print("You can take the test later by examining the file.")
    elif choice == "2":
        # Take interactive test
        results = administrator.create_interactive_test()
        if results:
            print(f"\n✅ Test completed! Results saved.")
    else:
        print("Invalid choice. Please run again and choose 1 or 2.")


if __name__ == "__main__":
    main()
